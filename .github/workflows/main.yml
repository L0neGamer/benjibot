# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [main]
  pull_request:

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  ormolu:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: mrkkrp/ormolu-action@v4

  generate-matrix:
    name: Generate GHC build matrix for Cabal
    runs-on: ubuntu-latest
    outputs:
      ghc-matrix: ${{ steps.set-ghc-matrix.outputs.versions }}
    steps:
      - uses: actions/checkout@v2

      - name: Parse the cabal tested-with stanza
        id: parse
        run: |
          echo "tested-with-versions=$(runghc .github/workflows/parseVersions.hs)" >> $GITHUB_OUTPUT

      - name: Set the GHC matrix for the next job
        id: set-ghc-matrix
        # We use single quotes here, since the output from the previous step
        # will not have escaped double quotes, and it's just easier to use single
        # quotes on the outside than try to escape the inner double quotes.
        run: echo 'versions={"ghc-version":${{ steps.parse.outputs.tested-with-versions }}}' >> $GITHUB_OUTPUT

  build-cabal:
    name: Cabal Build Check
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      # Whether to stop other jobs in the matrix if one fails. This is undesirable
      # since we want to check e.g. it compiles on 8.10.7 regardless of the status
      # of 9.X.
      fail-fast: false
      # Feed the json from the previous job.
      matrix: ${{ fromJson(needs.generate-matrix.outputs.ghc-matrix) }}
    steps:
      - uses: actions/checkout@v2

      # Although the GitHub Action Runner comes with pre-installed Cabal and GHC,
      # we'll only use Cabal out of the box since that is independent of
      # the GHC version. For GHC, we'll use the Haskell setup action to install
      # the correct version needed for the build.
      - uses: haskell/actions/setup@v2
        id: setup-haskell
        with:
          # We install a global GHC
          ghc-version: ${{ matrix.ghc-version }}

      - name: "Cabal: Update cabal package database, generate build plan"
        run: |
          cabal update
          cabal build --dry-run

      - name: "Cabal: Cache Dependencies"
        id: cache
        uses: actions/cache@v2
        with:
          # Include the build plan file generated by cabal configure, but allow
          # restoring without its hash as long as the GHC version is the same.
          key: cabal-${{ runner.os }}-${{ matrix.ghc-version }}-${{ hashFiles('**/plan.json') }}
          restore-keys: |
            cabal-${{ runner.os }}-${{ matrix.ghc-version }}
          path: |
            ${{ steps.setup-haskell.outputs.cabal-store }}
            dist-newstyle

      - name: "Cabal: Build"
        run: cabal build

  build-stack:
    name: Stack Build Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      # Since the GitHub Action Runner comes with a pre-installed Stack, we'll
      # use that instead of installing our own through the Haskell setup action,
      # since all we need to test the stack build is Stack itself.

      - name: "Stack: Cache ~/.stack"
        id: cache-stack
        uses: actions/cache@v2
        with:
          path: ~/.stack
          key: stack-${{ runner.os }}-${{ hashFiles('stack.yaml') }}
          restore-keys: |
            stack-${{ runner.os }}

      - name: "Print GHC version resolved from stack.yaml"
        run: |
          stack ghc -- --version
          stack path --compiler-exe

      - name: "Stack: Build"
        run: stack build

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    permissions:
      packages: write
    needs:
      - ormolu
    if: success()
    steps:
      - uses: actions/checkout@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v2
        if: github.event_name != 'pull_request' # don't need to login if we're not pushing
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get Docker Metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: | # tag with commit hash and with 'latest'
            type=sha 
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }} # dont push on a pull request
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
